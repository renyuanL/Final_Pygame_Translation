'''
python期末功課
B0129009 李銘達
'''
import random, sys, pygame, time, copy
from pygame.locals import *

每秒更新 = 10 # 螢幕每秒刷新頻率
螢幕寬 = 640 # 畫面寬度
螢幕高 = 480 # 畫面長度
棋盤格子長寬 = 50 # 每格的長寬
棋橫格數 = 8 # 棋盤行格數
棋直格數 = 8 # 棋盤列格數
白子 = '白子值' 
黑子 = '黑子值' 
空棋盤 = '空值' 
提示格 = '提示格值' 
動畫速度 = 25 # 動畫速度 從1~100可任選

# 畫出棋盤後的上下左右剩餘空間
剩餘空間_橫 = int((螢幕寬 - (棋橫格數 * 棋盤格子長寬)) / 2)
剩餘空間_縱 = int((螢幕高 - (棋直格數 * 棋盤格子長寬)) / 2)

#           R    G    B		設定顏色
白      = (255, 255, 255)
黑      = (  0,   0,   0)
綠      = (  0, 155,   0)
淡藍 = (  0,  50, 255)
褐      = (174,  94,   0)

文字背景色一 = 淡藍
文字背景色二 = 綠
格線色 = 黑
文字色 = 白
提示格色 = 褐

'''主迴圈'''

遊戲初始=pygame.init
設定遊戲時間=pygame.time.Clock
設定顯示幕=pygame.display.set_mode
設定字體=pygame.font.Font
讀取圖片=pygame.image.load
設定遊戲標題=pygame.display.set_caption
延展圖片=pygame.transform.smoothscale

'''翻譯結束 主迴圈'''

def 主迴圈():
    global 主時間, 顯示幕, 字體, 大字體, 背景圖片

    遊戲初始()
    主時間 = 設定遊戲時間()
    顯示幕 = 設定顯示幕((螢幕寬, 螢幕高))
    設定遊戲標題('Flippy')
    字體 = 設定字體('freesansbold.ttf', 16)
    大字體 = 設定字體('freesansbold.ttf', 32)

    # 設背景圖
    棋盤圖 = 讀取圖片('flippyboard.png')
    # 用 smoothscale() 延展圖片當作棋盤圖
    棋盤圖 = 延展圖片(棋盤圖, (棋橫格數 * 棋盤格子長寬, 棋直格數 * 棋盤格子長寬))
    格圖 = 棋盤圖.get_rect()
    格圖.topleft = (剩餘空間_橫, 剩餘空間_縱)
    背景圖片 = 讀取圖片('flippybackground.png')
    # 用 smoothscale() 延展背景當背景圖
    背景圖片 = 延展圖片(背景圖片, (螢幕寬, 螢幕高))
    背景圖片.blit(棋盤圖, 格圖)

    # 執行遊戲
    while True:
        if 遊戲啟動() == False:
            break


'''遊戲啟動'''
隨機取得=random.choice
抓取產生事件=pygame.event.get
滑鼠按鈕=MOUSEBUTTONUP
顯示更新=pygame.display.update
'''翻譯結束  遊戲啟動'''
def 遊戲啟動():
    # 啟動黑白棋遊戲

    # 重設所有已儲存的陣列，做新的一局
    主棋盤 = 創新棋盤()
    重置棋盤(主棋盤)
    顯示提示 = False
    輪流下棋 = 隨機取得(['computer', 'player'])

    # 詢問玩家顏色
    畫棋盤(主棋盤)
    玩家顏色, 電腦顏色 = 玩家選取顏色()

    # 做出重新開始與提示的文字方塊以及點擊後的事件
    新遊戲文字方塊 = 字體.render('New Game', True, 文字色, 文字背景色二)
    新遊戲取得事件 = 新遊戲文字方塊.get_rect()
    新遊戲取得事件.topright = (螢幕寬 - 8, 10)
    提示文字方塊 = 字體.render('Hints', True, 文字色, 文字背景色二)
    提示取得事件 = 提示文字方塊.get_rect()
    提示取得事件.topright = (螢幕寬 - 8, 40)

    while True: # 遊戲主要執行迴圈
        # 保持玩家與電腦輪流下
        if 輪流下棋 == 'player':
            # 輪到玩家:
            if 取有效移動(主棋盤, 玩家顏色) == []:
                # 若無可以下的地方，直接break換對手下
                break
            點選下一步的位置 = None
            while 點選下一步的位置 == None:
                # 持續循環，直到點擊到可以下的地方

                if 顯示提示:
                    要畫哪格棋格 = 取得有效移動棋_提式格(主棋盤, 玩家顏色)
                else:
                    要畫哪格棋格 = 主棋盤

                檢查結束()
                for 事件 in 抓取產生事件(): # 事件處理迴圈
                    if 事件.type == 滑鼠按鈕:
                        # 處理滑鼠點擊事件
                        滑鼠_橫座標, 滑鼠_縱座標 = 事件.pos
                        if 新遊戲取得事件.collidepoint( (滑鼠_橫座標, 滑鼠_縱座標) ):
                            # 重新開局
                            return True
                        elif 提示取得事件.collidepoint( (滑鼠_橫座標, 滑鼠_縱座標) ):
                            # 顯示提示
                            顯示提示 = not 顯示提示
                        # 檢查點選位置是否為可以下的地方
                        點選下一步的位置 = 抓取滑鼠點選的位置(滑鼠_橫座標, 滑鼠_縱座標)
                        if 點選下一步的位置 != None and not 有效移動(主棋盤, 玩家顏色, 點選下一步的位置[0], 點選下一步的位置[1]):
                            點選下一步的位置 = None

                # 畫遊戲棋盤
                畫棋盤(要畫哪格棋格)
                顯示結束資訊_輸贏分數(要畫哪格棋格, 玩家顏色, 電腦顏色, 輪流下棋)

                # 做出重新開始與提示的文字方塊以及點擊後的事件
                顯示幕.blit(新遊戲文字方塊, 新遊戲取得事件)
                顯示幕.blit(提示文字方塊, 提示取得事件)

                主時間.tick(每秒更新)
                顯示更新()

            # 做移動並輪流
            做移動(主棋盤, 玩家顏色, 點選下一步的位置[0], 點選下一步的位置[1], True)
            if 取有效移動(主棋盤, 電腦顏色) != []:
                # 若電腦可以移動，換電腦下
                輪流下棋 = 'computer'

        else:
            # 輪電腦下:
            if 取有效移動(主棋盤, 電腦顏色) == []:
                # 若不可動，break換玩家動
                break

            # 畫遊戲棋盤
            畫棋盤(主棋盤)
            顯示結束資訊_輸贏分數(主棋盤, 玩家顏色, 電腦顏色, 輪流下棋)

            # 做出重新開始與提示的文字方塊以及點擊後的事件
            顯示幕.blit(新遊戲文字方塊, 新遊戲取得事件)
            顯示幕.blit(提示文字方塊, 提示取得事件)

            # 做出延遲，使得電腦也有做思考的樣子
            做出電腦思考時間的效果 = time.time() + random.randint(5, 15) * 0.1
            while time.time() < 做出電腦思考時間的效果:
                顯示更新()

            # 移動，並換玩家
            x, y = 取得電腦移動(主棋盤, 電腦顏色)
            做移動(主棋盤, 電腦顏色, x, y, True)
            if 取有效移動(主棋盤, 玩家顏色) != []:
                輪流下棋 = 'player'

    # 顯示最後分數
    畫棋盤(主棋盤)
    算分數 = 取分數(主棋盤)

    # 最後分數與文字訊息
    if 算分數[玩家顏色] > 算分數[電腦顏色]:
        顯示文字 = 'You beat the computer by %s points! Congratulations!' % \
               (算分數[玩家顏色] - 算分數[電腦顏色])
    elif 算分數[玩家顏色] < 算分數[電腦顏色]:
        顯示文字 = 'You lost. The computer beat you by %s points.' % \
               (算分數[電腦顏色] - 算分數[玩家顏色])
    else:
        顯示文字 = 'The game was a tie!'

    文字方塊 = 字體.render(顯示文字, True, 文字色, 文字背景色一)
    文字取得事件 = 文字方塊.get_rect()
    文字取得事件.center = (int(螢幕寬 / 2), int(螢幕高 / 2))
    顯示幕.blit(文字方塊, 文字取得事件)

    # 顯示是否在玩一局
    詢問再一次 = 大字體.render('Play again?', True, 文字色, 文字背景色一)
    詢問再一次_取得事件 = 詢問再一次.get_rect()
    詢問再一次_取得事件.center = (int(螢幕寬 / 2), int(螢幕高 / 2) + 50)

    # 回答:好
    再一次_好 = 大字體.render('Yes', True, 文字色, 文字背景色一)
    再一次_好_取得事件 = 再一次_好.get_rect()
    再一次_好_取得事件.center = (int(螢幕寬 / 2) - 60, int(螢幕高 / 2) + 90)

    # 回答:不好
    再一次_不好 = 大字體.render('No', True, 文字色, 文字背景色一)
    再一次_不好_取得事件 = 再一次_不好.get_rect()
    再一次_不好_取得事件.center = (int(螢幕寬 / 2) + 60, int(螢幕高 / 2) + 90)

    while True:
        # 一直抓事件，直到事件是點擊在好或不好的方塊上面
        檢查結束()
        for 事件 in 抓取產生事件(): # event handling loop
            if 事件.type == 滑鼠按鈕:
                滑鼠_橫座標, 滑鼠_縱座標 = 事件.pos
                if 再一次_好_取得事件.collidepoint( (滑鼠_橫座標, 滑鼠_縱座標) ):
                    return True
                elif 再一次_不好_取得事件.collidepoint( (滑鼠_橫座標, 滑鼠_縱座標) ):
                    return False
        顯示幕.blit(文字方塊, 文字取得事件)
        顯示幕.blit(詢問再一次, 詢問再一次_取得事件)
        顯示幕.blit(再一次_好, 再一次_好_取得事件)
        顯示幕.blit(再一次_不好, 再一次_不好_取得事件)
        顯示更新()
        主時間.tick(每秒更新)


def 轉棋盤座標(x, y):
    return 剩餘空間_橫 + x * 棋盤格子長寬 + int(棋盤格子長寬 / 2), 剩餘空間_縱 + y * 棋盤格子長寬 + int(棋盤格子長寬 / 2)

'''棋子變化'''
畫圓_棋子=pygame.draw.circle
'''翻譯結束  棋子變化'''
def 棋子變化(吃棋子_翻棋, 棋子顏色, 附帶棋子):
    
    
    if 棋子顏色 == 白子:
        附帶棋子_顏色 = 白
    else:
        附帶棋子_顏色 = 黑
    附帶棋子_橫座標, 附帶棋子_縱座標 = 轉棋盤座標(附帶棋子[0], 附帶棋子[1])
    畫圓_棋子(顯示幕, 附帶棋子_顏色, (附帶棋子_橫座標, 附帶棋子_縱座標), int(棋盤格子長寬 / 2) - 4)
    顯示更新()

    for 顏色參數_慢慢變取動畫效果 in range(0, 255, int(動畫速度 * 2.55)):
        if 顏色參數_慢慢變取動畫效果 > 255:
            顏色參數_慢慢變取動畫效果 = 255
        elif 顏色參數_慢慢變取動畫效果 < 0:
            顏色參數_慢慢變取動畫效果 = 0

        if 棋子顏色 == 白子:
            色 = tuple([顏色參數_慢慢變取動畫效果] * 3) # 讓顏色慢慢變 從黑到白
        elif 棋子顏色 == 黑子:
            色 = tuple([255 - 顏色參數_慢慢變取動畫效果] * 3) # 讓顏色慢慢變 從白到黑

        for x, y in 吃棋子_翻棋:
            畫圓_棋子中心_橫座標, 畫圓_棋子中心_縱座標 = 轉棋盤座標(x, y)
            畫圓_棋子(顯示幕, 色, (畫圓_棋子中心_橫座標, 畫圓_棋子中心_縱座標), int(棋盤格子長寬 / 2) - 4)
        顯示更新()
        主時間.tick(每秒更新)
        檢查結束()

'''畫棋盤'''
畫線=pygame.draw.line
畫取事件=pygame.draw.rect
'''翻譯結束  畫棋盤'''
def 畫棋盤(棋盤陣列):
    # 畫背景圖
    顯示幕.blit(背景圖片, 背景圖片.get_rect())

    # 畫棋盤格線
    for x in range(棋橫格數 + 1):
        # 橫格線
        開始_橫座標 = (x * 棋盤格子長寬) + 剩餘空間_橫
        開始_縱座標 = 剩餘空間_縱
        結束_橫座標 = (x * 棋盤格子長寬) + 剩餘空間_橫
        結束_縱座標 = 剩餘空間_縱 + (棋直格數 * 棋盤格子長寬)
        畫線(顯示幕, 格線色, (開始_橫座標, 開始_縱座標), (結束_橫座標, 結束_縱座標))
    for y in range(棋直格數 + 1):
        # 縱格線
        開始_橫座標 = 剩餘空間_橫
        開始_縱座標 = (y * 棋盤格子長寬) + 剩餘空間_縱
        結束_橫座標 = 剩餘空間_橫 + (棋橫格數 * 棋盤格子長寬)
        結束_縱座標 = (y * 棋盤格子長寬) + 剩餘空間_縱
        畫線(顯示幕, 格線色, (開始_橫座標, 開始_縱座標), (結束_橫座標, 結束_縱座標))

    # 畫出所有黑棋白棋與提示
    for x in range(棋橫格數):
        for y in range(棋直格數):
            畫圓_棋子中心_橫座標, 畫圓_棋子中心_縱座標 = 轉棋盤座標(x, y)
            if 棋盤陣列[x][y] == 白子 or 棋盤陣列[x][y] == 黑子:
                if 棋盤陣列[x][y] == 白子:
                    棋子顏色 = 白
                else:
                    棋子顏色 = 黑
                畫圓_棋子(顯示幕, 棋子顏色, (畫圓_棋子中心_橫座標, 畫圓_棋子中心_縱座標), int(棋盤格子長寬 / 2) - 4)
            if 棋盤陣列[x][y] == 提示格:
                畫取事件(顯示幕, 提示格色, (畫圓_棋子中心_橫座標 - 4, 畫圓_棋子中心_縱座標 - 4, 8, 8))


def 抓取滑鼠點選的位置(滑鼠_橫座標, 滑鼠_縱座標):
    
    
    for x in range(棋橫格數):
        for y in range(棋直格數):
            if 滑鼠_橫座標 > x * 棋盤格子長寬 + 剩餘空間_橫 and \
               滑鼠_橫座標 < (x + 1) * 棋盤格子長寬 + 剩餘空間_橫 and \
               滑鼠_縱座標 > y * 棋盤格子長寬 + 剩餘空間_縱 and \
               滑鼠_縱座標 < (y + 1) * 棋盤格子長寬 + 剩餘空間_縱:
                return (x, y)
    return None


def 顯示結束資訊_輸贏分數(棋盤陣列, 玩家顏色, 電腦顏色, 輪流下棋):
    # 畫出最後輸贏的分數訊息方塊
    算分數 = 取分數(棋盤陣列)
    分數文字方塊 = 字體.render("Player Score: %s    Computer Score: %s    %s's Turn" % (str(算分數[玩家顏色]), str(算分數[電腦顏色]), 輪流下棋.title()), True, 文字色)
    分數取事件 = 分數文字方塊.get_rect()
    分數取事件.bottomleft = (10, 螢幕高 - 5)
    顯示幕.blit(分數文字方塊, 分數取事件)


def 重置棋盤(棋盤陣列):
    # 所有棋盤陣列設為空
    for x in range(棋橫格數):
        for y in range(棋直格數):
            棋盤陣列[x][y] = 空棋盤

    # 設定遊戲初始的中間4子
    棋盤陣列[3][3] = 白子
    棋盤陣列[3][4] = 黑子
    棋盤陣列[4][3] = 黑子
    棋盤陣列[4][4] = 白子


def 創新棋盤():
    # 創一個空的棋盤陣列
    棋盤陣列 = []
    for i in range(棋橫格數):
        棋盤陣列.append([空棋盤] * 棋直格數)

    return 棋盤陣列


def 有效移動(棋盤陣列, 現在棋子, 起始位置_橫座標, 起始位置_縱座標):
    # 回傳此位置是否為有效
    
    if 棋盤陣列[起始位置_橫座標][起始位置_縱座標] != 空棋盤 or not 判斷是否在棋盤內(起始位置_橫座標, 起始位置_縱座標):
        return False

    棋盤陣列[起始位置_橫座標][起始位置_縱座標] = 現在棋子 # temporarily set the tile on the board.

    if 現在棋子 == 白子:
        吃掉的棋子 = 黑子
    else:
        吃掉的棋子 = 白子

    吃棋子_翻棋 = []
    # 檢查每個方向(8個方位)
    for 橫方向檢查, 縱方向檢查 in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:
        x, y = 起始位置_橫座標, 起始位置_縱座標
        x += 橫方向檢查
        y += 縱方向檢查
        if 判斷是否在棋盤內(x, y) and 棋盤陣列[x][y] == 吃掉的棋子:
            # 檢查是否可以吃
            x += 橫方向檢查
            y += 縱方向檢查
            if not 判斷是否在棋盤內(x, y):
                continue
            while 棋盤陣列[x][y] == 吃掉的棋子:
                x += 橫方向檢查
                y += 縱方向檢查
                if not 判斷是否在棋盤內(x, y):
                    break # 撞壁，跳出目前方向的檢查(while迴圈)，但仍繼續其他方向(for迴圈)
            if not 判斷是否在棋盤內(x, y):
                continue
            if 棋盤陣列[x][y] == 現在棋子:
                
                while True:
                    x -= 橫方向檢查
                    y -= 縱方向檢查
                    if x == 起始位置_橫座標 and y == 起始位置_縱座標:
                        break
                    吃棋子_翻棋.append([x, y])

    棋盤陣列[起始位置_橫座標][起始位置_縱座標] = 空棋盤 
    if len(吃棋子_翻棋) == 0: 
        return False
    return 吃棋子_翻棋


def 判斷是否在棋盤內(x, y):
    # 回傳是否在棋盤格子內
    return x >= 0 and x < 棋橫格數 and y >= 0 and y < 棋直格數

'''取得有效移動棋_提式格'''
複製陣列=copy.deepcopy
'''翻譯結束  取得有效移動棋_提式格'''
def 取得有效移動棋_提式格(棋盤陣列, 現在棋子):
    # 回傳新狀況下的提示格陣列
    提示格陣列 = 複製陣列(棋盤陣列)

    for x, y in 取有效移動(提示格陣列, 現在棋子):
        提示格陣列[x][y] = 提示格
    return 提示格陣列


def 取有效移動(棋盤陣列, 現在棋子):
    # 回傳所有有效移動的地方
    有效移動陣列 = []

    for x in range(棋橫格數):
        for y in range(棋直格數):
            if 有效移動(棋盤陣列, 現在棋子, x, y) != False:
                有效移動陣列.append((x, y))
    return 有效移動陣列


def 取分數(棋盤陣列):
    # 算出目前分數
    白子分數 = 0
    黑子分數 = 0
    for x in range(棋橫格數):
        for y in range(棋直格數):
            if 棋盤陣列[x][y] == 白子:
                白子分數 += 1
            if 棋盤陣列[x][y] == 黑子:
                黑子分數 += 1
    return {白子:白子分數, 黑子:黑子分數}


def 玩家選取顏色():
    # 判斷玩家點擊位置並設定玩家的顏色
    文字方塊 = 字體.render('Do you want to be white or black?', True, 文字色, 文字背景色一)
    文字取得事件 = 文字方塊.get_rect()
    文字取得事件.center = (int(螢幕寬 / 2), int(螢幕高 / 2))

    白子文字 = 大字體.render('White', True, 文字色, 文字背景色一)
    白子取事件 = 白子文字.get_rect()
    白子取事件.center = (int(螢幕寬 / 2) - 60, int(螢幕高 / 2) + 40)

    黑子文字 = 大字體.render('Black', True, 文字色, 文字背景色一)
    黑子取事件 = 黑子文字.get_rect()
    黑子取事件.center = (int(螢幕寬 / 2) + 60, int(螢幕高 / 2) + 40)

    while True:
        # 迴圈持續抓事件，直到點擊到兩個顏色之一
        檢查結束()
        for 事件 in 抓取產生事件(): # event handling loop
            if 事件.type == 滑鼠按鈕:
                滑鼠_橫座標, 滑鼠_縱座標 = 事件.pos
                if 白子取事件.collidepoint( (滑鼠_橫座標, 滑鼠_縱座標) ):
                    return [白子, 黑子]
                elif 黑子取事件.collidepoint( (滑鼠_橫座標, 滑鼠_縱座標) ):
                    return [黑子, 白子]

        
        顯示幕.blit(文字方塊, 文字取得事件)
        顯示幕.blit(白子文字, 白子取事件)
        顯示幕.blit(黑子文字, 黑子取事件)
        顯示更新()
        主時間.tick(每秒更新)


def 做移動(棋盤陣列, 現在棋子, 起始位置_橫座標, 起始位置_縱座標, 實際移動=False):
    
    
    吃棋子_翻棋 = 有效移動(棋盤陣列, 現在棋子, 起始位置_橫座標, 起始位置_縱座標)

    if 吃棋子_翻棋 == False:
        return False

    棋盤陣列[起始位置_橫座標][起始位置_縱座標] = 現在棋子

    if 實際移動:
        棋子變化(吃棋子_翻棋, 現在棋子, (起始位置_橫座標, 起始位置_縱座標))

    for x, y in 吃棋子_翻棋:
        棋盤陣列[x][y] = 現在棋子
    return True


def 判斷轉角(x, y):
    # 回傳是否在四角
    return (x == 0 and y == 0) or \
           (x == 棋橫格數 and y == 0) or \
           (x == 0 and y == 棋直格數) or \
           (x == 棋橫格數 and y == 棋直格數)

'''取得電腦移動'''
打亂順序=random.shuffle
'''翻譯結束  取得電腦移動'''
def 取得電腦移動(棋盤陣列, 電腦顏色):
    # 計算出電腦下一步走哪
    電腦可能的移動 = 取有效移動(棋盤陣列, 電腦顏色)

    
    打亂順序(電腦可能的移動)

    # 若是可以走轉角，就搶轉角的點(最優先)
    for x, y in 電腦可能的移動:
        if 判斷轉角(x, y):
            return [x, y]

    # 看走哪一個地方可以獲得最高分，就走那(第二優先)
    可獲的最佳分數 = -1
    for x, y in 電腦可能的移動:
        提示格陣列 = 複製陣列(棋盤陣列)
        做移動(提示格陣列, 電腦顏色, x, y)
        分 = 取分數(提示格陣列)[電腦顏色]
        if 分 > 可獲的最佳分數:
            最佳移動 = [x, y]
            可獲的最佳分數 = 分
    return 最佳移動

'''檢查結束'''
遊戲結束=pygame.quit
程式結束=sys.exit
'''翻譯結束  檢查結束'''
def 檢查結束():
    for 事件 in 抓取產生事件((QUIT, KEYUP)): # 事件處理迴圈
        if 事件.type == QUIT or (事件.type == KEYUP and 事件.key == K_ESCAPE):
            遊戲結束()
            程式結束()


if __name__ == '__main__':
    主迴圈()
